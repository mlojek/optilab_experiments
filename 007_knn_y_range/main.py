'''
Measure how many points generated by IPOP-CMA-ES fall within the y range
of the neighbors.
'''

from optilab.data_classes import Bounds, PointList, Point
from optilab.functions import ObjectiveFunction
from optilab.functions.benchmarks import CECObjectiveFunction
from optilab.functions.surrogate import SurrogateObjectiveFunction
from optilab.optimizers import CmaEs, Optimizer
import numpy as np
import faiss
import argparse
import pandas as pd
from tqdm import tqdm


class KNN_Prober(SurrogateObjectiveFunction):
    """
    Surrogate objective function using FAISS for fast KNN-based regression.
    """

    def __init__(
        self,
        num_neighbors: int,
        train_set: PointList = None,
    ) -> None:
        """
        Class constructor.

        Args:
            num_neighbors (int): Number of closest neighbors to use in regression.
            train_set (PointList): Training data for the model.
        """
        self.num_neighbors = num_neighbors

        self.faiss_index = None
        self.y_train = None

        super().__init__(
            f"FastKNN{num_neighbors}",
            train_set,
            {"num_neighbors": num_neighbors},
        )

        # tally counters
        self.below_range = 0
        self.in_range = 0
        self.over_range = 0

    def train(self, train_set: PointList) -> None:
        """
        Train the FAISS-based KNN Surrogate function with provided data.

        Args:
            train_set (PointList): Training data for the model.
        """
        super().train(train_set)

        x_train, y_train = self.train_set.pairs()
        x_train = np.array(x_train, dtype=np.float32)
        y_train = np.array(y_train, dtype=np.float32)

        self.faiss_index = faiss.IndexFlatL2(x_train.shape[1])
        self.faiss_index.add(x_train)  # pylint: disable=no-value-for-parameter
        self.y_train = y_train

    def __call__(self, point: Point) -> Point:
        """
        Estimate the function value at a given point using kNN regression.

        Args:
            point (Point): Point to estimate.

        Returns:
            Point: Estimated value of the function at the given point.
        """
        super().__call__(point)

        assert point.is_evaluated

        if len(self.train_set) < self.num_neighbors:
            raise ValueError("Train set length is below number of neighbors.")

        x_query = np.array([point.x], dtype=np.float32)
        distances, indices = (
            self.faiss_index.search(  # pylint: disable=no-value-for-parameter
                x_query,
                self.num_neighbors,
            )
        )

        knn_ys = self.y_train[indices][0]

        if point.y < min(knn_ys):
            self.below_range += 1
        elif point.y > max(knn_ys):
            self.over_range += 1
        else:
            self.in_range += 1

    def get_tally(self):
        return self.below_range, self.in_range, self.over_range


class KKN_Y_IPOP(CmaEs):
    def __init__(
        self,
        population_size: int,
        num_neighbors: int,
        buffer_size: int,
    ):
        # buffer cannot be smaller than the number of neighbors
        buffer_size = max(buffer_size, num_neighbors)

        self.tallies = []

        # Skipping super().__init__ and calling grandparent init instead.
        Optimizer.__init__(
            self,
            f"knn{num_neighbors}b{buffer_size}-ipop-cma-es",
            population_size,
            {"num_neighbors": num_neighbors, "buffer_size": buffer_size},
        )

    def get_sum_tallies(self):
        sum_below = sum(t[0] for t in self.tallies)
        sum_in = sum(t[1] for t in self.tallies)
        sum_over = sum(t[2] for t in self.tallies)
        sum_total = sum_below + sum_in + sum_over
        # assert sum_total > 0
        return sum_below / sum_total, sum_in / sum_total, sum_over / sum_total

    # pylint: disable=duplicate-code
    def optimize(
        self,
        function: ObjectiveFunction,
        bounds: Bounds,
        call_budget: int,
        tolerance: float,
        target: float = 0.0,
    ) -> PointList:
        current_population_size = self.metadata.population_size
        res_log = PointList(points=[])

        while not self._stop_external(
            res_log,
            current_population_size,
            call_budget,
            target,
            tolerance,
        ):
            es = self._spawn_cmaes(
                bounds,
                function.metadata.dim,
                current_population_size,
                len(bounds) / 2,
            )

            while not self._stop(
                es,
                res_log,
                current_population_size,
                call_budget,
                target,
                tolerance,
            ):
                solutions = PointList.from_list(es.ask())
                results = PointList(points=[function(x) for x in solutions.points])

                if len(res_log) >= self.metadata.hyperparameters["buffer_size"]:
                    prober = KNN_Prober(
                        self.metadata.hyperparameters["num_neighbors"],
                        PointList(
                            points=res_log.points[
                                -self.metadata.hyperparameters["buffer_size"] :
                            ]
                        ),
                    )
                    for r in results.points:
                        prober(r)
                    
                    tally = prober.get_tally()
                    self.tallies.append(tally)

                res_log.extend(results)
                x, y = results.pairs()
                es.tell(x, y)

            current_population_size *= 2

        return res_log



if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "year",
        type=int,
        choices=[2013, 2017],
        help="Year of CEC benchmark, either 2013 or 2017.",
    )
    parser.add_argument(
        "dim",
        type=int,
        help="Dimensionality of benchmark functions.",
    )
    parser.add_argument(
        "--start_from",
        type=int,
        default=1,
        help="Function number to start from.",
    )
    parser.add_argument(
        "--stop_at",
        type=int,
        default=100,
        help="Function number to stop at.",
    )
    args = parser.parse_args()

    # optimized problem
    DIM = args.dim
    BOUNDS = Bounds(-100, 100)
    FUNCS = {
        2013: [
            CECObjectiveFunction(2013, n, DIM)
            for n in range(args.start_from, min(args.stop_at + 1, 29))
        ],
        2017: [
            CECObjectiveFunction(2017, n, DIM)
            for n in range(args.start_from, min(args.stop_at + 1, 30))
        ],
    }
    TARGET = 0.0

    # hyperparams:
    POPSIZE = int(4 + np.floor(3 * np.log(DIM)))
    NUM_NEIGHBORS = DIM + 2
    BUFFER_SIZES = [m * POPSIZE for m in [2, 5, 10, 20, 30, 50]]
    NUM_RUNS = 51
    CALL_BUDGET = 1e4 * DIM
    TOL = 1e-8

    results = []

    for func in FUNCS[args.year]:
        fname = func.metadata.name
        print(fname)

        for buffer_size in BUFFER_SIZES:
            print(f"buffer_size={buffer_size}")
            knn_optimizer = KKN_Y_IPOP(POPSIZE, NUM_NEIGHBORS, buffer_size)

            for _ in tqdm(range(NUM_RUNS)):
                knn_optimizer.optimize(func, BOUNDS, CALL_BUDGET, TOL, TARGET)

            tally = knn_optimizer.get_sum_tallies()

            results.append(
                {
                    "function": fname,
                    "buffer_size": buffer_size,
                    "in_range": tally[1],
                }
            )

        df = pd.DataFrame(results)
        results_df = df.pivot(index="function", columns="buffer_size", values="in_range")
        results_df = results_df.reindex(columns=BUFFER_SIZES)

        results_df.to_csv("knn_y_range_ipop_results.csv")
